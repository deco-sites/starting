---
description: Aceitando Outras Se√ß√µes como Par√¢metros em Sua Se√ß√£o
since: 1.0.0
---

# Aceitando Outras Se√ß√µes como Par√¢metros em Sua Se√ß√£o

No deco, voc√™ pode criar [Se√ß√µes](/docs/pt-br/concepts/section) poderosas e flex√≠veis ao aceitar outras se√ß√µes como par√¢metros. Isso permite que voc√™ construa componentes modulares e compon√≠veis que podem ser facilmente personalizados e reutilizados em diferentes contextos.

## Vis√£o Geral

Ao criar uma Se√ß√£o que aceita outras se√ß√µes como par√¢metros, voc√™ define uma interface para as props do seu componente de Se√ß√£o. Essa interface inclui uma propriedade com o nome da sua escolha, que √© do tipo `Section`. O tipo `Section` √© um tipo gen√©rico que representa qualquer outra se√ß√£o no deco.

## Implementa√ß√£o

Para criar uma Se√ß√£o que aceita outras Se√ß√µes como par√¢metros, siga estas etapas:

1. Importe o tipo `Section` de `deco/blocks/section.ts`.

2. Defina uma interface para as props do seu componente de se√ß√£o. Inclua uma propriedade com nome de sua escolha, que √© do tipo `Section`.

```tsx
// MySection.tsx

import { Section } from "deco/blocks/section.ts";

export interface Props {
  myProp: Section;
}

export default function MySection({ myProp: { Component, props } }: Props) {
  return (
    <div>
      <Component {...props} />
    </div>
  );
}
```

3. Dentro do seu componente de se√ß√£o, acesse as propriedades `Component` e `props` da prop `myProp`. A propriedade `Component` representa a fun√ß√£o do componente da se√ß√£o passada como par√¢metro, e a propriedade `props` cont√©m as props dessa se√ß√£o.

## Exemplo

Digamos que voc√™ tenha uma se√ß√£o chamada `ProductCardSection` que renderiza um cart√£o de produto com base em algumas props:

```tsx
// ProductCardSection.tsx

export interface Props {
  title: string;
  price: number;
  imageUrl: string;
}

export default function ProductCardSection({ title, price, imageUrl }: Props) {
  return (
    <div>
      <img src={imageUrl} alt={title} />
      <h3>{title}</h3>
      <p>{price}</p>
    </div>
  );
}
```

Agora, voc√™ deseja criar uma se√ß√£o de ordem superior chamada `ProductContainerSection`, que aceita uma `ProductCardSection` como par√¢metro e a envolve em um cont√™iner:

```tsx
// ProductContainerSection.tsx

import { Section } from "deco/blocks/section.ts";

export interface Props {
  myProp: Section;
}

export default function ProductContainerSection({ myProp: { Component, props } }: Props) {
  return (
    <div className="flex gap-4">
      <Component {...props} />
    </div>
  );
}
```

Com essa configura√ß√£o, agora voc√™ pode usar `ProductContainerSection` para envolver qualquer outra se√ß√£o, incluindo `ProductCardSection`, e adicionar um cont√™iner ao redor dela.

Agora, suponha que voc√™ queira restringir sua se√ß√£o a `ProductCard` porque tem muitas se√ß√µes em seu site, mas apenas essa deve se encaixar nesse local, voc√™ pode fazer o seguinte:

```tsx
// ProductCardSection.tsx

import { JSX } from "preact";

// Defina um tipo nomeado, por exemplo, "ProductCard," apontando para `JSX.Element`
export type ProductCard = JSX.Element;

// Defina a interface de props
export interface Props {
  title: string;
  price: number;
  imageUrl: string;
}

// Implemente a se√ß√£o e especifique o tipo de retorno como "ProductCard"
export default function ProductCardSection({ title, price, imageUrl }: Props): ProductCard {
  return (
    <div>
      <img src={imageUrl} alt={title} />
      <h3>{title}</h3>
      <p>{price}</p>
    </div>
  );
}
```

Agora, voc√™ pode depender diretamente de `ProductCard`:

```tsx
// ProductContainerSection.tsx

import { Section } from "deco/blocks/section.ts";
import { ProductCard } from "./ProductCardSection.tsx";

// Especifique a interface de propriedades com `Section<ProductCard>`
export interface Props {
  myProp: Section<ProductCard>;
}

// Implemente a se√ß√£o
export default function ProductContainerSection({ myProp: { Component, props } }: Props) {
  return (
    <div className="flex gap-4">
      <Component {...props} />
    </div>
  );
}
```

Isso garante consist√™ncia e refor√ßa o conceito de um tipo nomeado, tornando mais f√°cil para os desenvolvedores e usu√°rios de neg√≥cios restringirem suas se√ß√µes conforme desejado!

## Nota

Com a capacidade de aceitar outras se√ß√µes como par√¢metros, voc√™ pode criar se√ß√µes altamente modulares e personaliz√°veis que se adaptam a diferentes casos de uso e tornam suas aplica√ß√µes deco ainda mais poderosas e flex√≠veis. Boa codifica√ß√£o! üß©üöÄ
